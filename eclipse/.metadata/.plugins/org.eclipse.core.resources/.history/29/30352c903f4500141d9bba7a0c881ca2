package woop;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.util.Iterator;
import java.util.List;
import java.util.Properties;
import java.util.Random;

import net.minecraft.block.Block;
import net.minecraft.block.BlockSand;
import net.minecraft.client.Minecraft;
import net.minecraft.entity.EnumCreatureType;
import net.minecraft.init.Blocks;
import net.minecraft.util.IProgressUpdate;
import net.minecraft.world.ChunkPosition;
import net.minecraft.world.SpawnerAnimals;
import net.minecraft.world.World;
import net.minecraft.world.biome.BiomeGenBase;
import net.minecraft.world.chunk.Chunk;
import net.minecraft.world.chunk.IChunkProvider;
import net.minecraft.world.gen.MapGenBase;
import net.minecraft.world.gen.NoiseGeneratorOctaves;
import net.minecraft.world.gen.feature.WorldGenBigMushroom;
import net.minecraft.world.gen.feature.WorldGenCactus;
import net.minecraft.world.gen.feature.WorldGenClay;
import net.minecraft.world.gen.feature.WorldGenFire;
import net.minecraft.world.gen.feature.WorldGenFlowers;
import net.minecraft.world.gen.feature.WorldGenMinable;
import net.minecraft.world.gen.feature.WorldGenPumpkin;
import net.minecraft.world.gen.feature.WorldGenReed;
import net.minecraft.world.gen.feature.WorldGenerator;

public class BiosphereGen implements IChunkProvider
{
    private static final File cfgfile = new File(Minecraft.getMinecraft().mcDataDir, "/config/Biosphere.cfg");
    public final Random rndSphere;
    public final Random rndNoise;
    public final World world;
    public final boolean features;
    private MapGenBase caveGen = new BiosphereCaveGen();
    private NoiseGeneratorOctaves noiseGen;
    public static final int GRID_SIZE;
    private static final int BRIDGE_SIZE;
    public static final int SPECIAL_RADIUS;
    public static final int LAVA_LEVEL;
    public static final Block DOME_TYPE;
    public static final Block BRIDGE_SUPPORT;
    public static final Block BRIDGE_RAIL;
    public static final boolean NOISE;
    public static final boolean ENABLED;
    public static final boolean TALLGRASS;
    public static final boolean WATERWORLD;
    public static final boolean EXPLOITBUG;
    public int midX;
    public int midY;
    public int midZ;
    public int oreMidX;
    public int oreMidY;
    public int oreMidZ;
    public int lakeMidY;
    public double sphereRadius;
    public double lakeRadius;
    public double lakeEdgeRadius;
    public double noiseMin = Double.MAX_VALUE;
    public double noiseMax = Double.MIN_VALUE;
    public BiomeGenBase biome;
    public boolean hasLake;
    public boolean lavaLake;
    public final float scale = 1.0F;
    public final int scaledGrid;
    public final int scaledSpecial;
    public double[] noise = new double[256];
    public static final int heightShift = 7;
    public static final int xShift = 11;
    public static final int worldHeight = 128;
    public static final int worldMaxY = 127;
    public static final int seaLevel = 63;

    public BiosphereGen(World world1, long l, boolean flag)
    {
        this.rndSphere = new Random(l);
        this.world = world1;
        this.features = flag;
        this.scaledGrid = (int)((float)GRID_SIZE * 1.0F);
        this.scaledSpecial = (int)((float)SPECIAL_RADIUS * 1.0F);

        if (NOISE)
        {
            this.rndNoise = new Random(l);
            this.noiseGen = new NoiseGeneratorOctaves(this.rndNoise, 4);
        }
        else
        {
            this.rndNoise = null;
        }
    }

    public void setRand(int i, int j)
    {
        this.midX = (i - (int)Math.floor(Math.IEEEremainder((double)i, (double)this.scaledGrid)) << 4) + 8;
        this.midZ = (j - (int)Math.floor(Math.IEEEremainder((double)j, (double)this.scaledGrid)) << 4) + 8;
        this.oreMidX = this.midX + this.scaledGrid / 2 * 16 - this.scaledSpecial;
        this.oreMidZ = this.midZ + this.scaledGrid / 2 * 16 - this.scaledSpecial;
        this.rndSphere.setSeed(this.world.getSeed());
        long l = this.rndSphere.nextLong() / 2L * 2L + 1L;
        long l1 = this.rndSphere.nextLong() / 2L * 2L + 1L;
        long l2 = ((long)this.midX * l + (long)this.midZ * l1) * 2512576L ^ this.world.getSeed();
        this.rndSphere.setSeed(l2);
        this.sphereRadius = (double)((float)Math.round(16.0D + this.rndSphere.nextDouble() * 32.0D + this.rndSphere.nextDouble() * 16.0D) * 1.0F);
        this.lakeRadius = (double)Math.round(this.sphereRadius / 4.0D);
        this.lakeEdgeRadius = this.lakeRadius + 2.0D;
        this.biome = this.world.getWorldChunkManager().getBiomeGenAt(i << 4, j << 4);
        this.lavaLake = this.biome == BiomeGenBase.hell || this.biome != BiomeGenBase.swampland && this.biome != BiomeGenBase.taiga && this.biome != BiomeGenBase.icePlains && this.biome != BiomeGenBase.sky && this.rndSphere.nextInt(10) == 0;
        this.hasLake = this.biome == BiomeGenBase.swampland || this.biome != BiomeGenBase.sky && this.rndSphere.nextInt(2) == 0;
        this.oreMidY = this.scaledSpecial + 1 + this.rndSphere.nextInt(127 - (this.scaledSpecial + 1));

        if (NOISE)
        {
            this.setNoise(this.midX >> 4, this.midZ >> 4);
            this.noiseMin = Double.MAX_VALUE;

            for (int k = 0; k < this.noise.length; ++k)
            {
                if (this.noise[k] < this.noiseMin)
                {
                    this.noiseMin = this.noise[k];
                }
            }

            this.lakeMidY = (int)Math.round(63.0D + this.noiseMin * 8.0D * 1.0D);
            this.setNoise(i, j);
        }
        else
        {
            this.lakeMidY = this.midY;
        }
    }

    public void setNoise(int i, int j)
    {
        if (NOISE)
        {
            double d = 0.0078125D;
            this.noise = this.noiseGen.generateNoiseOctaves(this.noise, i * 16, 128, j * 16, 16, 1, 16, d, 1.0D, d);
        }
    }

    public double getMainDistance(int i, int j, int k)
    {
        return (double)Math.round(getDistance((double)i, (double)j, (double)k, (double)this.midX, (double)this.midY, (double)this.midZ));
    }

    public double getOreDistance(int i, int j, int k)
    {
        return (double)Math.round(getDistance((double)i, (double)j, (double)k, (double)this.oreMidX, (double)this.oreMidY, (double)this.oreMidZ));
    }

    public int getSurfaceLevel(int i, int j)
    {
        return NOISE ? (int)Math.round(63.0D + this.noise[j + i * 16] * 8.0D * 1.0D) : 63;
    }

    public void preGenerateChunk(int i, int j, Block[] abyte0)
    {
        int k = i << 4;
        int l = j << 4;

        for (int i1 = 0; i1 < 16; ++i1)
        {
            for (int j1 = 0; j1 < 16; ++j1)
            {
                this.midY = this.getSurfaceLevel(j1, i1);

                for (int k1 = 127; k1 >= 0; --k1)
                {
                    double d = this.getMainDistance(k + j1, k1, l + i1);
                    double d1 = this.getOreDistance(k + j1, k1, l + i1);
                    int l1 = j1 << 11 | i1 << 7 | k1;
                    Block byte0 = Blocks.air;

                    if (k1 > this.midY)
                    {
                        if (d == this.sphereRadius)
                        {
                            if (k1 >= this.midY + 4 || Math.abs(k + j1 - this.midX) > BRIDGE_SIZE && Math.abs(l + i1 - this.midZ) > BRIDGE_SIZE)
                            {
                                byte0 = DOME_TYPE;
                            }
                        }
                        else if (this.hasLake && NOISE && this.biome != BiomeGenBase.desert && (d == this.lakeRadius + 1.0D || d == this.lakeRadius + 2.0D))
                        {
                            if (k1 == this.lakeMidY)
                            {
                                byte0 = this.biome.topBlock;
                            }
                            else if (k1 < this.lakeMidY)
                            {
                                byte0 = this.biome.fillerBlock;
                            }
                        }
                        else if (this.hasLake && NOISE && this.biome != BiomeGenBase.desert && d <= this.lakeRadius)
                        {
                            if (k1 == this.lakeMidY && this.biome == BiomeGenBase.icePlains)
                            {
                                byte0 = Blocks.ice;
                            }
                            else if (k1 <= this.lakeMidY)
                            {
                                byte0 = (this.lavaLake ? Blocks.flowing_lava : Blocks.flowing_water);
                            }
                        }
                        else if (WATERWORLD && k1 <= this.midY + 4 && d > this.sphereRadius && (Math.abs(k + j1 - this.midX) == BRIDGE_SIZE || Math.abs(l + i1 - this.midZ) == BRIDGE_SIZE))
                        {
                            byte0 = DOME_TYPE;
                        }
                        else if (WATERWORLD && k1 == this.midY + 4 && d > this.sphereRadius && (Math.abs(k + j1 - this.midX) < BRIDGE_SIZE || Math.abs(l + i1 - this.midZ) < BRIDGE_SIZE))
                        {
                            byte0 = DOME_TYPE;
                        }
                        else if (WATERWORLD && k1 < this.midY + 4 && d > this.sphereRadius && (Math.abs(k + j1 - this.midX) < BRIDGE_SIZE || Math.abs(l + i1 - this.midZ) < BRIDGE_SIZE))
                        {
                            byte0 = Blocks.air;
                        }
                        else if (WATERWORLD && d > this.sphereRadius)
                        {
                            byte0 = Blocks.water;
                        }
                        else if (k1 == this.midY + 1 && d > this.sphereRadius && (Math.abs(k + j1 - this.midX) == BRIDGE_SIZE || Math.abs(l + i1 - this.midZ) == BRIDGE_SIZE))
                        {
                            byte0 = BRIDGE_RAIL;
                        }
                    }
                    else if (d == this.sphereRadius)
                    {
                        byte0 = Blocks.stone;
                    }
                    else if (this.hasLake && this.biome != BiomeGenBase.desert && d <= this.lakeRadius)
                    {
                        if (k1 == this.lakeMidY && this.biome == BiomeGenBase.icePlains)
                        {
                            byte0 = Blocks.ice;
                        }
                        else if (k1 <= this.lakeMidY)
                        {
                            byte0 = (this.lavaLake ? Blocks.flowing_lava : Blocks.flowing_water);
                        }
                    }
                    else if (this.hasLake && k1 < this.lakeMidY - 1 && this.biome != BiomeGenBase.desert && d <= this.lakeEdgeRadius)
                    {
                        byte0 = (this.lavaLake ? Blocks.gravel : Blocks.sand);
                    }
                    else if (d < this.sphereRadius)
                    {
                        if (k1 == this.midY)
                        {
                            byte0 = this.biome.topBlock;
                        }
                        else if (k1 == this.midY - 1)
                        {
                            byte0 = this.biome.fillerBlock;
                        }
                        else
                        {
                            byte0 = Blocks.stone;
                        }
                    }
                    else if (k1 == this.midY && d > this.sphereRadius && (Math.abs(k + j1 - this.midX) < BRIDGE_SIZE + 1 || Math.abs(l + i1 - this.midZ) < BRIDGE_SIZE + 1))
                    {
                        byte0 = BRIDGE_SUPPORT;
                    }
                    else if (WATERWORLD && d > this.sphereRadius)
                    {
                        byte0 = Blocks.water;
                    }

                    if (d1 <= (double)this.scaledSpecial)
                    {
                        int i2 = this.rndSphere.nextInt(500);
                        Block j2 = Blocks.stone;

                        if (i2 < 1)
                        {
                            j2 = Blocks.lapis_ore;
                        }
                        else if (i2 < 2)
                        {
                            j2 = Blocks.emerald_ore;
                        }
                        else if (i2 < 3)
                        {
                            j2 = Blocks.diamond_ore;
                        }

                        byte0 = j2;
                    }

                    abyte0[l1] = byte0;
                }
            }
        }
    }

    public static final double getInverseDistance(double d, double d1, double d2, double d3, double d4, double d5)
    {
        return Math.sqrt(-Math.pow(d4 - d1, 2.0D) + Math.pow(d3 - d, 2.0D) + Math.pow(d5 - d2, 2.0D));
    }

    public static final double getDistance(double d, double d1, double d2, double d3, double d4, double d5)
    {
        return Math.sqrt(Math.pow(d4 - d1, 2.0D) + Math.pow(d3 - d, 2.0D) + Math.pow(d5 - d2, 2.0D));
    }

    /**
     * loads or generates the chunk at the chunk location specified
     */
    public Chunk loadChunk(int i, int j)
    {
        return this.provideChunk(i, j);
    }

    /**
     * Will return back a chunk, if it doesn't exist and its not a MP client it will generates all the blocks for the
     * specified chunk from the map seed and chunk seed
     */
    public Chunk provideChunk(int i, int j)
    {
        this.setRand(i, j);
        Block[] abyte0 = new Block[32768 * (EXPLOITBUG ? 2 : 1)];
        this.preGenerateChunk(i, j, abyte0);
        this.caveGen.generate(this, this.world, i, j, abyte0);
        Chunk chunk = new Chunk(this.world, abyte0, i, j);
        chunk.generateSkylightMap();
        return chunk;
    }

    /**
     * Checks to see if a chunk exists at x, y
     */
    public boolean chunkExists(int i, int j)
    {
        return true;
    }

    /**
     * Populates chunk with ores etc etc
     */
    public void populate(IChunkProvider ichunkprovider, int i, int j)
    {
        BlockSand.fallInstantly = true;
        int k = i << 4;
        int l = j << 4;
        this.biome = this.world.getWorldChunkManager().getBiomeGenAt(k, l);
        this.rndSphere.setSeed(this.world.getSeed());
        long l1 = this.rndSphere.nextLong() / 2L * 2L + 1L;
        long l2 = this.rndSphere.nextLong() / 2L * 2L + 1L;
        this.rndSphere.setSeed((long)i * l1 + (long)j * l2 ^ this.world.getSeed());
        int k4;
        int k18;
        int k9;
        int l18;

        for (k4 = 0; k4 < 10; ++k4)
        {
            k18 = k + this.rndSphere.nextInt(16);
            k9 = this.rndSphere.nextInt(128);
            l18 = l + this.rndSphere.nextInt(16);
            (new WorldGenClay(4)).generate(this.world, this.rndSphere, k18, k9, l18);
        }

        for (k4 = 0; k4 < 20; ++k4)
        {
            k18 = k + this.rndSphere.nextInt(16);
            k9 = this.rndSphere.nextInt(128);
            l18 = l + this.rndSphere.nextInt(16);
            (new WorldGenMinable(Blocks.coal_ore, 16)).generate(this.world, this.rndSphere, k18, k9, l18);
        }

        for (k4 = 0; k4 < 20; ++k4)
        {
            k18 = k + this.rndSphere.nextInt(16);
            k9 = this.rndSphere.nextInt(128);
            l18 = l + this.rndSphere.nextInt(16);
            (new WorldGenMinable(Blocks.iron_ore, 8)).generate(this.world, this.rndSphere, k18, k9, l18);
        }

        for (k4 = 0; k4 < 2; ++k4)
        {
            k18 = k + this.rndSphere.nextInt(16);
            k9 = this.rndSphere.nextInt(128);
            l18 = l + this.rndSphere.nextInt(16);
            (new WorldGenMinable(Blocks.gold_ore, 8)).generate(this.world, this.rndSphere, k18, k9, l18);
        }

        for (k4 = 0; k4 < 8; ++k4)
        {
            k18 = k + this.rndSphere.nextInt(16);
            k9 = this.rndSphere.nextInt(128);
            l18 = l + this.rndSphere.nextInt(16);
            (new WorldGenMinable(Blocks.redstone_ore, 7)).generate(this.world, this.rndSphere, k18, k9, l18);
        }

        k4 = this.biome.theBiomeDecorator.treesPerChunk;

        if (this.rndSphere.nextInt(10) == 0)
        {
            ++k4;
        }

        for (k18 = 0; k18 < k4; ++k18)
        {
            k9 = k + this.rndSphere.nextInt(16) + 8;
            l18 = l + this.rndSphere.nextInt(16) + 8;
            WorldGenerator i19 = this.biome.getRandomWorldGenForTrees(this.rndSphere);
            i19.setScale(1.0D, 1.0D, 1.0D);
            i19.generate(this.world, this.rndSphere, k9, this.world.getHeightValue(k9, l18), l18);
        }

        int var18;

        for (k18 = 0; k18 < 2; ++k18)
        {
            k9 = k + this.rndSphere.nextInt(16) + 8;
            l18 = this.rndSphere.nextInt(128);
            var18 = l + this.rndSphere.nextInt(16) + 8;
            (new WorldGenFlowers(Blocks.yellow_flower)).generate(this.world, this.rndSphere, k9, l18, var18);
        }

        if (this.rndSphere.nextInt(2) == 0)
        {
            k18 = k + this.rndSphere.nextInt(16) + 8;
            k9 = this.rndSphere.nextInt(128);
            l18 = l + this.rndSphere.nextInt(16) + 8;
            (new WorldGenFlowers(Blocks.red_flower)).generate(this.world, this.rndSphere, k18, k9, l18);
        }

        if (this.rndSphere.nextInt(4) == 0)
        {
            k18 = k + this.rndSphere.nextInt(16) + 8;
            k9 = this.rndSphere.nextInt(128);
            l18 = l + this.rndSphere.nextInt(16) + 8;
            (new WorldGenFlowers(Blocks.brown_mushroom_block)).generate(this.world, this.rndSphere, k18, k9, l18);
        }

        if (this.rndSphere.nextInt(8) == 0)
        {
            k18 = k + this.rndSphere.nextInt(16) + 8;
            k9 = this.rndSphere.nextInt(128);
            l18 = l + this.rndSphere.nextInt(16) + 8;
            (new WorldGenFlowers(Blocks.red_mushroom_block)).generate(this.world, this.rndSphere, k18, k9, l18);
        }

        int l13;

        if (TALLGRASS)
        {
            k18 = this.biome.theBiomeDecorator.grassPerChunk;

            for (k9 = 0; k9 < k18; ++k9)
            {
                byte var19 = 1;

                if (this.biome == BiomeGenBase.desert && this.rndSphere.nextInt(3) != 0)
                {
                    var19 = 2;
                }

                var18 = k + this.rndSphere.nextInt(16) + 8;
                l13 = this.rndSphere.nextInt(128);
                int d = l + this.rndSphere.nextInt(16) + 8;
                (new WorldGenTallGrass(Blocks.tallgrass, var19)).generate(this.world, this.rndSphere, var18, l13, d);
            }
        }

        for (k18 = 0; k18 < 20; ++k18)
        {
            k9 = k + this.rndSphere.nextInt(16) + 8;
            l18 = this.rndSphere.nextInt(128);
            var18 = l + this.rndSphere.nextInt(16) + 8;
            (new WorldGenReed()).generate(this.world, this.rndSphere, k9, l18, var18);
        }

        if (this.rndSphere.nextInt(32) == 0)
        {
            k18 = k + this.rndSphere.nextInt(16) + 8;
            k9 = this.rndSphere.nextInt(128);
            l18 = l + this.rndSphere.nextInt(16) + 8;
            (new WorldGenPumpkin()).generate(this.world, this.rndSphere, k18, k9, l18);
        }

        if (this.biome == BiomeGenBase.desert)
        {
            for (k18 = 0; k18 < this.rndSphere.nextInt(5); ++k18)
            {
                k9 = k + this.rndSphere.nextInt(16) + 8;
                l18 = this.midY;
                var18 = l + this.rndSphere.nextInt(16) + 8;
                (new WorldGenCactus()).generate(this.world, this.rndSphere, k9, l18, var18);
            }
        }
        else if (this.biome == BiomeGenBase.hell)
        {
            if (this.rndSphere.nextBoolean())
            {
                k18 = k + this.rndSphere.nextInt(16) + 8;
                k9 = this.midY;
                l18 = l + this.rndSphere.nextInt(16) + 8;
                (new WorldGenFire()).generate(this.world, this.rndSphere, k18, k9, l18);
            }
        }
        else if (this.biome == BiomeGenBase.mushroomIsland)
        {
            for (k18 = 0; k18 < 2; ++k18)
            {
                k9 = k + this.rndSphere.nextInt(16) + 8;
                l18 = l + this.rndSphere.nextInt(16) + 8;
                (new WorldGenBigMushroom()).generate(this.world, this.rndSphere, k9, this.world.getHeightValue(k9, l18), l18);
            }

            for (k18 = 0; k18 < 1; ++k18)
            {
                if (this.rndSphere.nextInt(4) == 0)
                {
                    k9 = k + this.rndSphere.nextInt(16) + 8;
                    l18 = l + this.rndSphere.nextInt(16) + 8;
                    var18 = this.world.getHeightValue(k9, l18);
                    (new WorldGenFlowers(Blocks.yellow_flower)).generate(this.world, this.rndSphere, k9, var18, l18);
                }

                if (this.rndSphere.nextInt(8) == 0)
                {
                    k9 = k + this.rndSphere.nextInt(16) + 8;
                    l18 = l + this.rndSphere.nextInt(16) + 8;
                    var18 = this.rndSphere.nextInt(128);
                    (new WorldGenFlowers(Blocks.red_flower)).generate(this.world, this.rndSphere, k9, var18, l18);
                }
            }
        }
        else if (this.biome == BiomeGenBase.taiga || this.biome == BiomeGenBase.icePlains)
        {
            this.setNoise(i, j);

            for (k18 = 0; k18 < 16; ++k18)
            {
                for (k9 = 0; k9 < 16; ++k9)
                {
                    this.midY = this.getSurfaceLevel(k9, k18);
                    l18 = k9 + k;
                    var18 = k18 + l;
                    l13 = this.midY + 1;
                    double var20 = this.getMainDistance(l18, this.midY, var18);

                    if (var20 <= this.sphereRadius && this.world.isBlockFreezable(l18, l13, var18))
                    {
                        this.world.setBlock(l18, l13, var18, Block.blockSnow.blockID);
                    }
                }
            }
        }

        if (!EXPLOITBUG)
        {
            SpawnerAnimals.performWorldGenSpawning(this.world, this.biome, k + 8, l + 8, 16, 16, this.rndSphere);
        }

        BlockSand.fallInstantly = false;
    }

    /**
     * Two modes of operation: if passed true, save all Chunks in one go.  If passed false, save up to two chunks.
     * Return true if all chunks have been saved.
     */
    public boolean saveChunks(boolean flag, IProgressUpdate iprogressupdate)
    {
        return true;
    }

    /**
     * Unloads chunks that are marked to be unloaded. This is not guaranteed to unload every such chunk.
     */
    public boolean unloadQueuedChunks()
    {
        return false;
    }

    /**
     * Returns if the IChunkProvider supports saving.
     */
    public boolean canSave()
    {
        return true;
    }

    /**
     * Converts the instance data to a readable string.
     */
    public String makeString()
    {
        return "RandomLevelSource";
    }

    /**
     * Returns a list of creatures of the specified type that can spawn at the given location.
     */
    public List getPossibleCreatures(EnumCreatureType enumcreaturetype, int i, int j, int k)
    {
        BiomeGenBase biomegenbase = this.world.getBiomeGenForCoords(i, k);
        return biomegenbase == null ? null : biomegenbase.getSpawnableList(enumcreaturetype);
    }

    /**
     * Returns the location of the closest structure of the specified type. If not found returns null.
     */
    public ChunkPosition findClosestStructure(World world1, String s, int i, int j, int k)
    {
        return null;
    }

    public int getLoadedChunkCount()
    {
        return 0;
    }

    public void recreateStructures(int var1, int var2) {}

    public void func_104112_b() {}

    static
    {
        BiomeGenBase.hell.topBlock = BiomeGenBase.hell.fillerBlock = Blocks.netherrack;
        BiomeGenBase.sky.topBlock = BiomeGenBase.sky.fillerBlock = Blocks.end_stone;
        Block byte0 = Blocks.glass; // 20 == glass(?)
        
        boolean flag = true;
        boolean flag1 = true;
        boolean flag2 = true;
        boolean flag3 = false;
        boolean flag4 = false;
        int i = 9;
        int j = 7;
        int k = 24;
        int l = 2;
        byte byte1 = 5;
        byte byte2 = 85;

        try
        {
            cfgfile.getParentFile().mkdirs();

            if (cfgfile.exists() || cfgfile.createNewFile())
            {
                Properties props = new Properties();

                if (cfgfile.canRead())
                {
                	try
                	{
                    FileInputStream fs = new FileInputStream(cfgfile);
                    props.load(fs);

                    byte0 = WoopMod.ParseBlock(props.getProperty("dome", "20"));
                    flag = Boolean.parseBoolean(props.getProperty("noise", "true"));
                    flag1 = Boolean.parseBoolean(props.getProperty("enabled", "true"));
                    flag2 = Boolean.parseBoolean(props.getProperty("tall_grass", "true"));
                    flag3 = Boolean.parseBoolean(props.getProperty("water_world", "false"));
                    flag4 = Boolean.parseBoolean(props.getProperty("exploit_bug", "false"));
                    i = Integer.parseInt(props.getProperty("grid", "9"));
                    j = Integer.parseInt(props.getProperty("special", "7"));
                    k = Integer.parseInt(props.getProperty("lavaLevel", "24"));
                    l = Integer.parseInt(props.getProperty("bridge_size", "2"));
                    byte1 = Byte.parseByte(props.getProperty("bridge_support", "5"));
                    byte2 = Byte.parseByte(props.getProperty("bridge_rail", "85"));
                    BiomeEntry iterator1;

                    for (Iterator biomeentry1 = BiosphereWeather.biomeList.iterator(); biomeentry1.hasNext(); iterator1.itemWeight = Integer.parseInt(props.getProperty("weight_" + iterator1.biome.biomeName, Integer.toString(iterator1.itemWeight))))
                    {
                        iterator1 = (BiomeEntry)biomeentry1.next();
                    }
                	}
                	finally
                	{
                		fs.close();
                	}
                }

                if (cfgfile.canWrite())
                {
                    FileOutputStream fileoutputstream1 = new FileOutputStream(cfgfile);
                    props.setProperty("dome", Byte.toString(byte0));
                    props.setProperty("noise", Boolean.toString(flag));
                    props.setProperty("enabled", Boolean.toString(flag1));
                    props.setProperty("tall_grass", Boolean.toString(flag2));
                    props.setProperty("water_world", Boolean.toString(flag3));
                    props.setProperty("exploit_bug", Boolean.toString(flag4));
                    props.setProperty("grid", Integer.toString(i));
                    props.setProperty("special", Integer.toString(j));
                    props.setProperty("lavaLevel", Integer.toString(k));
                    props.setProperty("bridge_size", Integer.toString(l));
                    props.setProperty("bridge_support", Byte.toString(byte1));
                    props.setProperty("bridge_rail", Byte.toString(byte2));
                    Iterator iterator11 = BiosphereWeather.biomeList.iterator();

                    while (iterator11.hasNext())
                    {
                        BiomeEntry biomeentry11 = (BiomeEntry)iterator11.next();
                        props.setProperty("weight_" + biomeentry11.biome.biomeName, Integer.toString(biomeentry11.itemWeight));
                    }

                    props.store(fileoutputstream1, "Biosphere Config");
                    fileoutputstream1.close();
                }
            }
        }
        catch (Throwable var16)
        {
            ;
        }

        DOME_TYPE = byte0;
        NOISE = flag;
        ENABLED = flag1;
        TALLGRASS = flag2;
        WATERWORLD = flag3;
        EXPLOITBUG = flag4;
        GRID_SIZE = i;
        SPECIAL_RADIUS = j;
        LAVA_LEVEL = k;
        BRIDGE_SIZE = l;
        BRIDGE_SUPPORT = byte1;
        BRIDGE_RAIL = byte2;

        if (WATERWORLD)
        {
            Block.lightOpacity[8] = 0;
            Block.lightOpacity[9] = 0;
        }
    }
}

