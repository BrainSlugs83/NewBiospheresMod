package woop;

import net.minecraft.block.Block;
import net.minecraft.entity.Entity;
import net.minecraft.entity.EntityLiving;
import net.minecraft.entity.EntityLivingBase;
import net.minecraft.entity.EnumCreatureType;
import net.minecraft.entity.player.EntityPlayer;
import net.minecraft.entity.player.EntityPlayerMP;
import net.minecraft.init.Blocks;
import cpw.mods.fml.common.eventhandler.Event;
import cpw.mods.fml.common.eventhandler.EventPriority;
import cpw.mods.fml.common.Mod;
import cpw.mods.fml.common.Mod.EventHandler;
import cpw.mods.fml.common.ModClassLoader;
import cpw.mods.fml.common.event.FMLInitializationEvent;
import cpw.mods.fml.common.eventhandler.SubscribeEvent;
import cpw.mods.fml.common.gameevent.PlayerEvent;
import cpw.mods.fml.common.registry.GameRegistry;
import cpw.mods.fml.common.registry.LanguageRegistry;
import net.minecraft.util.ChunkCoordinates;
import net.minecraft.world.World;
import net.minecraft.world.WorldProvider;
import net.minecraft.world.WorldType;
import net.minecraftforge.common.MinecraftForge;
import net.minecraftforge.event.entity.EntityEvent;
import net.minecraftforge.event.entity.EntityJoinWorldEvent;
import net.minecraftforge.event.entity.living.LivingSpawnEvent;
import net.minecraftforge.event.entity.living.LivingEvent.LivingUpdateEvent;

import java.util.HashMap;

@Mod(modid = WoopMod.MODID, version = WoopMod.VERSION)
public class WoopMod
{
	public static final String MODID = "WoopMod";
	public static final String VERSION = "Ver. 0";

	public static WorldType Biosphere;
	public static Events Events;

	@EventHandler
	public void Init(FMLInitializationEvent event)
	{
		// some example code
		// System.out.println("DIRT BLOCK >> " +
		// Blocks.dirt.getUnlocalizedName());

		// GameRegistry.addShapelessRecipe(new ItemStack(Blocks.diamond_block),
		// new ItemStack(Blocks.dirt));

		LanguageRegistry.instance().addStringLocalization("generator.biosphere", "Biospheres");
		Biosphere = new BiosphereGenerator("biosphere");

		// Events = new Events();
		// MinecraftForge.EVENT_BUS.register(Events);
		MinecraftForge.EVENT_BUS.register(this);
	}

	private static boolean SpawnedOnTopOfDome(Entity entity)
	{

		if (entity == null) { return false; }

		World world = entity.worldObj;
		if (world == null) { return false; }

		int domeBlockCount = 0;

		int x = (int)Math.round(entity.posX);
		int z = (int)Math.round(entity.posZ);

		for (double yo = -10; yo <= 10; yo++)
		{

			int y = (int)Math.round(entity.posY + yo);

			Block block = world.getBlock(x, y, z);

			// System.out.println("SPAWN BLOCK [" + x + ", " + y + ", "
			// + z
			// + "](" + yo + "): " +
			// WoopMod.GetNameOrIdForBlock(block));

			if (block == BiosphereGen.DOME_TYPE || block == Blocks.end_stone || block == Blocks.netherrack)
			{

				domeBlockCount++;

				if (domeBlockCount > 3)
				{

					// not dome world.
					return false;
				}
			}
			else if (block != Blocks.air)
			{

				if (block != Blocks.water && block != Blocks.flowing_water)
				{

					// not dome world.
					return false;
				}

				// One of the blocks is water...
				if (!BiosphereGen.WATERWORLD) { return false; }
			}
		}

		return domeBlockCount >= 1; // spawned on top of a dome!!
	}

	private static boolean ValidSpawnLocation(Entity entity)
	{

		if (entity == null) { return true; }

		World world = entity.worldObj;
		if (world == null) { return true; }

		int y = (int)Math.round(entity.posY);
		int x = (int)Math.round(entity.posX);
		int z = (int)Math.round(entity.posZ);

		for (int i = 0; i < 3; i++)
		{

			Block block = world.getBlock(x, y + 1, z);

			if (block != Blocks.air)
			{
				// trying to spawn in the middle of non-empty blocks
				return false;
			}
		}

		Block under = world.getBlock(x, y - 1, z);
		return under != Blocks.air && under != BiosphereGen.DOME_TYPE;
	}

	public static boolean TryFixSpawnLocation(Entity entity)
	{

		if (entity == null) { return false; }

		World world = entity.worldObj;
		if (world == null) { return false; }

		boolean printed = false;
		boolean locationModified = false;

		while (SpawnedOnTopOfDome(entity))
		{

			if (!printed)
			{

				printed = true;
				// System.out.printf("Invalid Spawn Location, Fixing (%s).%n",
				// GetName(entity));
				// System.out.printf("    Org. Location: [%.2f, %.2f, %.2f]%n",
				// entity.posX, entity.posY, entity.posZ);
			}

			entity.setPosition(
				Math.round(entity.posX) - 0.5d,
				Math.round(entity.posY) - 8.0d,
				Math.round(entity.posZ) - 0.5d);

			while (!ValidSpawnLocation(entity))
			{

				entity.setPosition(entity.posX, entity.posY - 1.0d, entity.posZ);
			}

			locationModified = true;
		}

		if (locationModified)
		{

			// System.out.printf("    Final Location: [%.2f, %.2f, %.2f]%n",
			// entity.posX, entity.posY, entity.posZ);
		}

		return locationModified;
	}

	HashMap<Entity, ChunkCoordinates> pendingTeleports = new HashMap<Entity, ChunkCoordinates>();

	@SubscribeEvent
	public void EntityJoinWorldEvent(EntityJoinWorldEvent e)
	{
		if (e != null)
		{
			// System.out.println("Entity Joined World: "
			// + e.entity.getClass().getSimpleName());

			// Original Super Complicated Code (that also works):
			if (TryFixSpawnLocation(e.entity))
			{
				if (Utils.IsPlayer(e.entity))
				{
					// set coordinates will not be honored, we'll have to compensate. :(
					pendingTeleports.put(e.entity, Utils.GetCoords(e.entity));
				}
			}
		}
	}

	@SubscribeEvent
	public void LivingUpdateEvent(EntityLivingEvent e)
	{
		if (e == null || e.entity == null) { return; }
		if (e instanceof EntityJoinWorldEvent) { return; } 

		if (pendingTeleports.containsKey(e.entity))
		{
			System.out.println("EVENT: " + e.getClass().getName() + ", ENTITY: " + Utils.GetName(e.entity));

			ChunkCoordinates location = pendingTeleports.get(e.entity);
			//pendingTeleports.remove(e.entity);

			e.entity.setPosition(location.posX, location.posY, location.posZ);
			
		}
	}

}
